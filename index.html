<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Portable Web Publications for the Open Web Platform</title>
    <link rel="stylesheet" type="text/css" href="extras.css" />
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" async="" class="remove"></script>
    <style type="text/css">
      code {
        font-size: 120%;
      }
      span.orcid a {
          text-decoration: none !important;
          border-bottom: none !important;
      }
      span.orcid a img {
          transform: translateY(0.18em) translateX(-0.18em);
      }

      aside.annotation {
          float: right;
          background: yellow;
          width: 30%;
          padding:1em;
          margin-left: 1em;
          margin-bottom: 1em;
          margin-top: 1em;
          border: 1px solid black;
          transform: translateX(-1em);
      }
      span.annotation {
          background:yellow;
      }

    </style>
    <script class="remove">
      var respecConfig = {
         localBiblio: {
            "EPUB3": {
                "authors": [
                  "Garth Conboy",
                  "Matt Garrish",
                  "Markus Gylling",
                  "William McCoy",
                  "Murata Makoto",
                  "Daniel Weck"
                ],
                "title": "EPUB 3 Overview",
                "href" : "http://www.idpf.org/epub/301/spec/epub-overview-20140626.html",
                "rawDate": "2014-06-26",
                "status" : "Recommended Specification",
                "publisher": "IDPF"
            },
            "OCF": {
                "authors": [
                  "James Pritchett",
                  "Markus Gylling"
                ],
                "title": "EPUB Open Container Format (OCF) 3.0",
                "href" : "http://www.idpf.org/epub/301/spec/epub-ocf-20140626.html",
                "rawDate": "2014-06-26",
                "status" : "Recommended Specification",
                "publisher": "IDPF"
            },
            "EPUBCFI": {
                 "authors": [
                  "Peter Sorotokin",
                  "Garth Conboy",
                  "Brady Duga",
                  "John Rivlin",
                  "Don Beaver",
                  "Kevin Ballard",
                  "Alastair Fettes",
                  "Daniel Weck"
                ],
                "title": "EPUB Canonical Fragment Identifier (epubcfi) Specification",
                "href" : "http://www.idpf.org/epub/linking/cfi/epub-cfi.html",
                "rawDate": "2014-06-26",
                "status" : "Recommended Specification",
                "publisher": "IDPF"
            },
            "ODF": {
                "authors": [
                  "Michael Brauer",
                  "Patrick Durusau",
                  "Gary Edwards",
                  "David Faure",
                  "Tom Magliery",
                  "Daniel Vogelheim"
                ],
                "title": "Open Document Format for Office Applications v1.0",
                "href" : "https://www.oasis-open.org/committees/download.php/12572/OpenDocument-v1.0-os.pdf",
                "rawDate": "2005-05-01",
                "status" : "Oasis Standard",
                "publisher": "Oasis"
            },
            "OOXML": {
                "authors" : [
                  "ECMA International"
                ],
                 "title": "Office Open XML File Formats, ECMA-376",
                "href" : "http://www.ecma-international.org/publications/standards/Ecma-376.htm",
                "rawDate": "2012-12",
                "status" : "Standard ECMA 376",
                "publisher": "ECMA"
            },
		    "web-manifest": {
		        "title": "Manifest for web application",
		        "href" : "https://w3c.github.io/manifest/",
		        "rawDate": "2015-02-23",
		        "status" : "ED",
		        "publisher": "W3C"
		    },
            "web-packaging": {
                "authors": [
                  "Jeni Tennison"
                ],
                "title": "Packaging on the Web",
                "href" : "http://www.w3.org/TR/web-packaging/",
                "rawDate": "2015-01-15",
                "status" : "WD",
                "publisher": "W3C"
            },
            "ONIX": {
                "authors": [
                  "EDItEUR"
                ],
                "title": "ONIX for Books 3.0.2 Specification",
                "rawDate": "2014-01-02",
                "publisher": "EDItEUR"
            },
            "BigJava" : "Cay Horstmann. <em>Big Java Late Objects</em>, John Wiley &amp; Sons, Inc., 2013",
            "web-workers" : {
                "authors": [
                  "Ian Hickson"
                ],
                "title": "Web Workers",
                "href" : "https://w3c.github.io/workers/",
                "rawDate": "2014-05-19",
                "status" : "ED",
                "publisher": "W3C"
            },
            "file-uri-scheme" : {
              "authors": [
                "M. Kervin"
              ],
              "title": "The file URI Scheme",
              "href" : "https://tools.ietf.org/html/draft-ietf-appsawg-file-scheme-03",
              "rawDate": "2015-07-23",
              "status" : "Internet Draft",
              "publisher": "IETF"
            },
            "CSV" : {
              "authors" : [
                "Yakov Shafranovich"
              ],
              "title" : "Common Format and MIME Type for Comma-Separated Values (CSV) Files",
              "href" : "http://tools.ietf.org/html/rfc4180",
              "rawDate" : "2015-10",
              "status" : "Informational RFC",
              "publisher": "IETF"
            },
            "ISBN-URN" : {
              "authors" : [
                "J. Hakala",
                "H. Walravens"
              ],
              "title" : "Using International Standard Book Numbers as Uniform Resource Names",
              "href" : "http://tools.ietf.org/html/rfc3187",
              "rawDate" : "2001-10",
              "status" : "Informational RFC",
              "publisher": "IETF"
            },
            "UUID" : {
              "authors" : [
                "P. Leach",
                "M. Mealling",
                "R. Salz"
              ],
              "title" : "A Universally Unique IDentifier (UUID) URN Namespace",
              "href" : "http://tools.ietf.org/html/rfc4122",
              "rawDate" : "2005-07",
              "status" : "Informational RFC",
              "publisher": "IETF"
            },
            "pwp-ucr" : {
                "authors" : [
                    "Heather Flanagan",
                    "Ivan Herman"
                ],
                "title" : "Portable Web Publications Use Cases and Requirements",
                "href" : "http://www.w3.org/TR/pwp-ucr/",
                "publisher" : "W3C",
                "rawDate": "2016-09-13",
                "status": "Working Draft"
            }
          },

          // These may become useful if the document gets a more 'official' status
          // postProcess : [ postProc ],

          doRdfa: "true",
          // specification status (e.g. WD, LCWD, WG-NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "pwp",
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "White Paper",
          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2016-04-28",
          // if the specification's copyright date is a range of years, specify
          // the start date here:
          copyrightStart: "2015",
          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2016-03-16",
          previousMaturity:  "WD",
          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://w3c.github.io/dpub-pwp/",
          // Possibility to add permalinks (a ยง character) to each id-d section
          //   includePermalinks: "true",
          //   permalinkEdge: "true",
          //   permalinkHide: "true",


          githubAPI: "https://api.github.com/repos/w3c/dpub-pwp",
          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",
          // editors, add as many as you like
          // only "name" is required
          editors:  [
             {
                      name:       "Markus Gylling"
                  ,   mailto:     "markus.gylling@gmail.com"
                  ,   company:    "DAISY Consortium"
                  ,   companyURL: "http://www.daisy.org/"
                  ,   w3cid:      "21614"
              },
              {
                      name:       "Ben De Meester"
                  ,   mailto:     "ben.demeester@ugent.be"
                  ,   company:    "Ghent University - iMinds - Data Science Lab"
                  ,   companyURL: "http://www.iminds.be/"
                  ,   url:        "http://users.ugent.be/~bjdmeest/"
                  ,   extras: [{
                        name:  "<img src='figures/orcid_logo.png' />",
                        href:  "http://orcid.org/0000-0003-0248-0987",
                        class: "orcid"
                      }]
                  ,   w3cid:      "73403"
              },
              {
                      name:       "Ivan Herman"
                  ,   mailto:     "ivan@w3.org"
                  ,   company:    "W3C"
                  ,   companyURL: "http://www.w3.org"
                  ,   url:        "http://www.w3.org/People/Ivan/"
                  ,   extras:     [{
                        name:  "<img src='figures/orcid_logo.png' />",
                        href:  "http://orcid.org/0000-0003-0782-2704",
                        class: "orcid"
                      }]
                  ,   w3cid:      "7382"
              },
              {
                      name:       "Tzviya Siegman"
                  ,   mailto:     "tsiegman@wiley.com"
                  ,   company:    "John Wiley & Sons, Inc."
                  ,   companyURL: "http://www.wiley.com"
                  ,   w3cid:      "65542"
              },
          ],
          // name of the Group
          wg:           "Digital Publishing Interest Group",
          // URI of the public Group page
          wgURI:        "http://www.w3.org/dpub/IG/",
          // name (without the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-digipub-ig",
          issueBase: "https://github.com/w3c/dpub-pwp/issues/",
          noRecTrack : "true",
          otherLinks: [
            {
              key: "Repository",
              data: [{
                value: "Github Repository",
                href: "https://github.com/w3c/dpub-pwp"
              }]
            },
            {
              key: "Issues tracker",
              data: [{
                value: "Github Issue Tracker",
                href: "https://github.com/w3c/dpub-pwp/issues"
              }]
            },
            {
              key: "Changes",
              data: [{
                  value: "Diff to previous version",
                  href: "diff.html"
                }, {
                  value: "Commit history",
                  href: "https://github.com/w3c/dpub-pwp/commits/gh-pages"
              }]
            }
           ],
           alternateFormats: [
               {
                   uri: "pwp.epub",
                   label: "ePub"
               }
           ],
          charterDisclosureURI : "http://www.w3.org/2004/01/pp-impl/64149/status",
          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/64149/status",
          // !!!! IMPORTANT !!!! MAKE THE ABOVE BLINK IN YOUR HEAD
      };
    </script>
  </head>
  <body>
    <section id="abstract">
        <blockquote class="quote">
            <p>โA book is a discrete collection of text (and other media), that is designed by an author(s) as an internally complete representation of an idea, or set of ideas; emotion or set of emotions; and transmitted to readers in various formats.โ</p>
            <p>โBooks can learn from the Web how to be bounded, but open.<br>
                The Web can learn from books how to be open, but bounded.โ</p>
                <p class="author">Hugh McGuire, <a href="https://medium.com/@hughmcguire/what-books-can-learn-from-the-web-what-the-web-can-learn-from-books-64670171908f#.482p2ksyi">Medium, April 2016</a>
        </blockquote>

      <p>This document introduces Portable Web Publications, a vision for the future of digital publishing that is based on a fully native representation of documents within the Open Web Platform. Portable Web Publications achieve full convergence between online and offline/portable document publishing: publishers and users won't need to choose one or the other, but can switch between them dynamically, at will. Authors can concentrate on the way they intend to transmit their ideas and emotions, without having to deal with the specificities of a particular format.
      </p>
    </section>

    <section id='sotd'>
      <p>This document outlines a general vision and should not be considered a technical specification. Instead, its goal is to outline that vision and possible technical directions to achieve it, and reflects the discussions that occured in the Digital Publishing Interest Group. In partiucular, this document looks at some of the technical implications, and possible solutions, arising from the use cases and requirements collected by the Digital Publishing Interest Group, and documented in a separate UCR document&nbsp[[pwp-ucr]]. As such, some of the sections are more detailed and more mature than others. A more detailed and rigoruous specification should be done by a separated, dedicated Working Group in the future.</p>
    </section>

    <section id="introduction">
      <h2>The vision of publishing on the Web</h2>
      <section>
            <h2>The high level vision</h2>

            <p>The Web emerged in 1994, based on a model of individual pages loosely joined by hyperlinks. Clustering within domains, with explicit navigation elements built into them, webpages evolved into websites. This model however inherited very little from an existing, powerful and much older page-based media: books.</p>

            <p>Over centuries, โbooksโ have assumed many forms: journals, magazines, pamphlets of longform articles and essays, newspapers, atlases, comics, notebooks, albums of all sorts. We can define these different manifestations as โpublicationsโ: bound editions of meaningful media, made public.</p>

            <p>We believe there is great value in combining this older traditionโof portable, bounded publicationsโwith the pervasive accessibility, addressability, and interconnectedness of the <a href="https://www.w3.org/wiki/Open_Web_Platform">Open Web Platform</a>. New models of economic sustainability, innovative experiences of knowledge and invigorated socio-cultural engagement depend on this.</p>

            <p>It is the task of this W3C Digital Publishing Interest Group to explore the uniqueness, desirability, and feasibility of bringing these two great models of publishing together. This document explores the technical feasibility and some of the challenges arising from real use cases that arise when exploring this vision further. Many of these challenges arise from the various use cases, documented in the separate note on PWP Use Cases and Requirement&nbsp;[[pwp-ucr]]
            </p>
      </section>
      <section>
          <h2>The technical vision</h2>

          <p>From a technical viewpoint, our vision for <a>Portable Web Publications</a> is to define a class of documents on the Web that would be part of the Digital Publishing ecosystem but would also be fully native citizens of the <a href="https://www.w3.org/wiki/Open_Web_Platform">Open Web Platform</a>.  In this vision, the current format- and workflow-level separation between offline/portable and online (Web) document publishing is diminished to zero. These are merely two dynamic manifestations of the same publication: content authored with online use as the primary mode can easily be saved by the user for offline reading in portable document form. Content authored primarily for use as a portable document can be put online, without any need for refactoring the content. Publishers can choose to utilize either or both of these publishing modes, and users can choose either or both of these consumption modes. Essential features flow seamlessly between online and offline modes; examples include cross-references, user annotations, access to online databases, as well as licensing and rights management.
          </p>

          <p>A more precise technical definition of <a>Portable Web Publications</a> is provided in the section <a href='#pwp_definition'></a>. For the sake of this introduction, it suffices to say that a <a>Portable Web Publication</a> is a collection of resources (e.g. pages, chapters, modules, articles) whose content is compatible with Web usage, and structured as a single, self-contained logical unit. Individual items can consist of text, images, graphics, possibly interactive mathematical or chemical formulae, as well as audio and video. These documents, by definition, have a default, linear โreading orderโ, however the user may choose to skip around in the content just as with a book on paper; alternatively, interactive aspects of the content may alter the reading order on behalf of the user.
          </p>

          <p>As mentioned already, a companion document&nbsp;[[pwp-ucr]] collects a set of more detailed use cases and requirements for <a>Portable Web Publications</a>. The present document concentrates on the technical challenges to achieve this vision, and provides some technical directions aiming to address some of those challenges. None of the technical solutions should be considered final; a more detailed and rigorous specification should be done by a separate, dedicated Working Group.</p>

          <figure id="pwp_figure" >
            <img src="figures/pwp.svg" alt="Image showing a laptop accessing unpackaged multiple files for online use.  With same content packaged for use on a mobile cellphone." style="width:80%">
            <figcaption>The same content can be turned into an archived file and back without any inherent changes to the core content or associated digital assets. (Picture is available separately in <a href="figures/pwp.svg">SVG</a> or <a href="figures/pwp.png">PNG</a> formats.)</figcaption>
          </figure>
      </section>
    </section>


    <section id="whynow">
      <h2>Why work on this now?</h2>

      <p>Digital Publishing can be considered to be at a tipping point. Digital publishing formats like EPUB have been broadly adopted globally for trade ebooks, and are starting to gain adoption among textbook publishers as well as corporate marketing departments. However, these formats have largely been seen as โofflineโ formats up until now. Various browser extensions supporting such complex publications exist, and other solutions are available for delivering these publications in browsers. Browser- and cloud-based solutions require relatively complex server and/or client software. In many cases browser- and cloud-based solutions depend on a proprietary transformation of the packaged files into formats more suitable to network delivery. A focused effort to make digital publications first-class Open Web Platform citizens will result in a significant reduction in the complexity of deploying publishing content into browsers for both online and offline consumption. Further, this focused effort will increase the momentum of digital publication and associated Web adoption across communities who are looking for an open, non-proprietary, next-generation portable document format.</p>

      <aside class="annotation"><em>Ivan:</em> I am not sure we should keep this section. It is not our role to talk about the broader Web Platform in general; it is a slippery slope in terms of unnecessary discussions with Web Developers, without any real use for PWP.</aside>
      <p>The broader Web Platform can also be considered to be at a tipping point. Mobile platform web site use is diminishing in favor of native applications. Hybrid applications that use web content alongside native application technology, and web-technology-based system applications are growing. The specific means of delivering hybrid and web-technology-based system applications is currently proprietary to specific applications frameworks and/or browser platforms. The point of Portable Web Publications is to increase problem solving momentum in package, metadata, and offline support applicable to both portable publications and installed applications. Open and native solutions to replace proprietary packaging, metadata, and offline support are intended to ensure the broadest possible general adoption of the Open Web Platform.
      </p>

      <aside class="annotation overlage"><em>Ivan:</em> this paragraph (or a version thereof) may replace the previous oneโฆ</aside>
      <p>A convergence between Digital Publications and the Web in general is also beneficial for โtraditionalโ Web content; many of the use cases described in [[pwp-ucr]] (e.g., usage of pagination for long form publications, the fact of considering a collection of resources as a single unit, etc.) are relevant for highly informative, albeit possibly less interactive Web content as well. The experience in ergonomy, production workflow, editorial craftmanship, etc., that the (Digital) Publishing industry has developed over the centuries may also have a positive influence on the evolution of Web content at large. Technically, in many respect, the development of Portable Web Publications is in line with <a href="https://en.wikipedia.org/wiki/Progressive_web_app">Progressive Web Apps</a> coming to the fore, insofar as breaking the boundaries between Web sites and Mobile Applications, an emphasis on โofflineโ paradigms, etc. (It is also worth noting that the technical approach explored in this document rely on the same technologies.)
      </p>

      <p>In many respects, the convergence is already happening. In a number of areas (e.g., educational publications, travel books, etc.) publishers already exploit the advanced possibilities of packaged publishing formats to produce highly interactive documents whose features are very close to what one is used to on the Web (see the separate section <a href="#epub-relations"></a> for some examples). And the converse is also true: tutorial and introductory articles have appeared on the Web that have the quality of traditional publications that one was used to seeing in a scientific magazine, but combined with the interactive possibilities of the Web (<a href="http://bost.ocks.org/mike/algorithms/">Mike Bostockโs article on visualizing algorithms</a> or <a href="http://worrydream.com/LadderOfAbstraction/">Bret Victorโs article on visualization</a> are just two of several possible examples). โTraditionalโ publications (for example in scholarly publishing) are increasingly moving on-line, exploring new possibilities and publishing paradigms, but also facing issues in combining their traditional requirements with the reality of the Web today. All in all, the convergence still has a long way to go, and this is the topic that this document, and the concept of <a>Portable Web Publications</a>, aim to explore.
      </p>
    </section>


    <section id="terminology">
      <h2>Terminology</h2>
      <p>This document is based on the following definitions.</p>

      <section id="pwp_definition">
        <h2>Portable Web Publications</h2>

        <ul class="definition">
          <li> A <dfn>Web Resource</dfn> is a digital resource that can be uniquely addressed by a [[URL]] or a [[file-uri-scheme]], i.e., whose content can be accessed through standard network protocols such as HTTP, FTP, or the File Protocol.</li>

          <li><dfn>Content</dfn> of a <a>Web Resource</a>: information and sensory experience to be communicated to the user by means of a user agent, including code or markup that defines the contentโs structure, presentation, and interactions.</li>

          <li><dfn data-lt="essential">Essential Content</dfn> of a <a>Web Resource</a>: <a>content</a> which, if removed, would fundamentally change the information or <a>functionality</a> of the <a>Web Resource</a>.</li>

          <li><dfn>Functionality</dfn> related to a <a>Web Resource</a>: processes and outcomes achievable through user action.</li>

          <li>A <dfn data-lt="Web Publications">Web Publication</dfn> is a <a>Web Resource</a> which itself is an aggregated set of interrelated <a data-lt="Web Resource">Web Resources</a>, and which is intended to be considered as a single <a>Web Resource</a>. Furthermore:
            <ul>
              <li>As a <a>Web Resource</a>, a <a>Web Publication</a> has its own [[URL]] which refers to the <em>full set</em> of the constituent resources (as opposed to a particular <a>Web Resource</a> <em>within</em> the <a>Web Publication</a>).</li>

              <li>A <a>Web Publication</a> must be constructed of resources whose formats enable (individually or in conjunction with other resources in the same <a>Web Publication</a>) delivery of <a>essential content</a> and <a>functionality</a> when delivered via a variety of technologies or delivery platforms. In particular, the essential constituents of a <a>Web Publication</a> must be based on technologies of the <a href="https://www.w3.org/wiki/Open_Web_Platform">Open Web Platform</a>.</li>

              <li>A <a>Web Publication</a> should provide a gracefully degrading experience when delivered via a variety of technologies or delivery platforms.</li>

              <li>A <a>Web Publication</a> should provide accessible access to <a>content</a>.</li>

              <li>A <a>Web Publication</a> is not an object with a precise technical meaning, e.g., it is not necessarily equivalent to an HTML Document.</li>
            </ul>
          </li>

          <li>A <a>Web Resource</a> within a <a>Web Publication</a> is <dfn data-lt="Portable Web Resource|Portable Web Resources">Portable</dfn> if an OWP compliant user agent can render its <a>essential content</a> by relying essentially on the <a data-lt="Web Resource">Web Resources</a> within the same <a>Web Publication</a></li>

          <li>A <dfn data-lt="Portable Web Publication|Portable Web Publications|PWP">Portable Web Publication</dfn> (PWP) is a <a>Web Publication</a> whose constituent <a data-lt="Web Resource">Web Resources</a> are all <a data-lt="Portable Web Resource">Portable</a>.</li>
        </ul>

        <p class="note">See the separate section <a href="#identification"></a> for further details on addressing <a>Web Publications</a>.</p>

        <p id="pwp_content"><a data-lt="Web Resource">Web Resources</a> in a <a data-lt="Portable Web Publication">(Portable) Web Publication</a> are based on core <a href="https://www.w3.org/wiki/Open_Web_Platform">Open Web Platform</a> technologies like [[html5]], [[svg]], [[css21]] and CSS3 modules, or [[ECMAScript]] API-s. A <a>Web Publication</a> may also include images, audio and video, metadata files, executable code in, for example, <a href="http://ipython.org/">iPython</a> or <a href="http://www.maplesoft.com/products/maple/">Maple</a> scripts, or datafiles in [[CSV]]: <a data-lt="Web Resource">Web Resources</a> that are needed to render the <a>essential content</a> of the publication.</p>

        <p>The differences between the distinguishing characteristics of <a>Web Publications</a> and <a data-lt="Portable Web Publication"><span style="text-decoration:underline">Portable</span> Web Publications</a> can be viewed as situational and gradual rather than as representative of bright-line distinctions. Consider the following example:</p>

        <aside class="example">
           <p>The usage of a particular font within a <a>Web Publication</a> may be regarded as non-essential and its font file may therefore be missing from the publication; because the user agent can fall back on a system font, thereby rendering the <a>essential content</a> of the publication, this particular publication may be considered as portable. In other cases, however, the font is <a>essential</a> for the content (e.g., because the font represents mathematical or musical symbols) in which case the <a>Web Publication</a> may be considered as portable only if the font files are part of the constituent set.</p>
        </aside>

        <p class="note">The concepts of <a>content</a>, <a>essential content</a>, and <a>functionality</a> have been taken over from the W3C Web Content Accessibility Guidelines [[WCAG20]], thought slightly modified for this context.</p>
      </section>

      <section id="state_definition">
        <h3>States of a Portable Web Publication</h3>

        <p>The <dfn data-lt="state">states</dfn> of a <a>Portable Web Publication</a> can be separated into two different axes. These different states require a different behavior from the user agent, while some of the characteristics of the publication may be invariant across states. The different states are as follows:</p>

        <ol class="definition">
          <li><strong>States related to the organization of the <a data-lt="Web Resource">Web Resources</a></strong>: A <a>Portable Web Publication</a> is in
            <ul>
              <li><dfn data-lt="Packed">Packed State</dfn>: when all constituent <a data-lt="Web Resource">Web Resources</a> are combined into one unit for storage in a file system, network transfer, etc.</li>
              <li><dfn data-lt="Unpacked">Unpacked State</dfn>: when all constituent <a data-lt="Web Resource">Web Resources</a> can be directly accessed individually.</li>
            </ul>
          </li>

          <li><strong>States related to the access of <a data-lt="Web Resource">Web Resources</a></strong>: A <a>Portable Web Publication</a> is in
            <ul>
              <li><dfn data-lt="Protocol">Protocol State</dfn>: when all constituent <a data-lt="Web Resource">Web Resources</a>, as well as the <a>Portable Web Publication</a> itself, are accessed through network protocols like HTTP, HTTPS, or FTP</li>
              <li><dfn data-lt="File">File State</dfn>: when all constituent <a data-lt="Web Resource">Web Resources</a>, as well as the <a>Portable Web Publication</a> itself, are accessed as files on a local file system</li>
            </ul>
          </li>
        </ol>

        <p>The table below shows the same publication (PWP) in the most typical states:</p>

        <table class="zebra">
          <tbody>
            <tr>
              <th></th>
              <th>Protocol</th>
              <th>File</th>
            </tr>
            <tr>
              <th>Packed</th>
              <td>PWP as one archive file on a Web Server</td>
              <td>PWP as one archive file on a local disc</td>
            </tr>
            <tr>
              <th>Unpacked</th>
              <td>PWP spread over several files on a Web Server</td>
              <td>PWP spread over several files on a local disc</td>
            </tr>
          </tbody>
        </table>

        <aside class="note">The difference between <a>protocol</a> and <a>file</a> states is not identical, although close, to the difference between the commonly used notions of โonlineโ vs. โofflineโ. A PWP can be on a local disc but accessed through a Web Server running on that machine (i.e., through a <code>http://localhost</code> URL): the PWP is in a <a>protocol</a> state, though clearly โofflineโ. Similarly, a remote file system can be mounted as a local disc, in which case a PWP can be accessed as a file, i.e., is in a <a>file</a> state, though possibly โonlineโ. </aside>
      </section>

      <section id="locator_definitions">
          <h2>Locators</h2>
          <p>The term โlocatorโ is used to denote URI addressing a <a>Web Resource</a>. More specifically, in the context of <a>Portable Web Publications</a>, the following definitions hold:</p>

          <ul class="definition">
              <li>An <dfn>identifier</dfn> is a string that uniquely identifies a <a>Portable Web Publication</a>. An identifier may be a generic string, a number, a URI, etc.; for the purpose of this document there are no restrictions although, on the Web, a URI is the preferred format. What exactly <em>is</em> identified (a work, like Shakespeareโs Hamlet, or a particular instance of that work in a particular library) is not addressed in this document and is left to specialized organizations.</li>

              <li>The (PWP) <dfn>server</dfn> has the responsibility of serving the <a data-lt="Portable Web Publication">PWP-s</a> in their different states. As such, the <a>server</a> is always aware of all possible published states of the <a>PWP</a>.

                <p class='note'>A server can be configured in multiple ways to serve the various <a>states</a> of a <a>PWP</a>, e.g., possibly respond to content negotations. This specification does not rely any particular configuration.</p>
              </li>

              <li>A <dfn>locator</dfn> is a URL that points to either an entire <a>PWP</a> or a resource <em>within</em> a <a>PWP</a>.
              </li>

              <li>A <dfn>PWP locator</dfn> is a <a>locator</a> to the <a>PWP</a> as a whole. This <a>PWP Locator</a> can be dereferenced via an HTTP(S) request and should return some information. As such, it is not the same as an identifier, although, it <em>could</em> be the same.
              </li>

              <li>A <dfn>relative locator</dfn> is a locator to a resource within a <a>PWP</a>, without specifying the location of the <a>PWP</a>.</li>

              <li>An <dfn>absolute locator</dfn> is a combination of a <a>PWP locator</a> and a <a>relative locator</a>.</li>

              <li>The <dfn>state independent locator</dfn> (sometimes referred to as a โcanonicalโ locator) is an absolute, and <a data-lt="state">state independent</a> <a>PWP locator</a>. For the purposes of this document, the state independent locator of a PWP is denoted by <strong>L</strong>.
              </li>

              <li>A <dfn data-lt="state locator|state locators">state locator</dfn> is a <a>PWP locator</a> that refers to a PWP in a particular <a>state</a>. For the purposes of this document, <strong>L<sub>u</sub></strong> denotes the <a>state locator</a> referring to an <a>unpacked state</a>, whereas <strong>L<sub>p</sub></strong> refers to a <a>state locator</a> referring to a <a>packed state</a>.

                  <p>There is no requirement that the <a>state independent locator</a> <em>must</em> be different from the locator of the published, unpacked <a>state</a> of the <a>PWP</a>.</p>

                  <p class="note">In practice, it may be possible to define several different PWP packaging formats, in which case there may be several <a>state locators</a> referring to packages. Their treatment, from the point of view of this document, are identical, hence this document is restricted to a single locator of this type. Also, the precise treatment of specific packaging formats (unpacking algorithms, etc.) are not relevant for this document.
                  </p>

                  <p class="note">
                      There is no requirement that the publisher publishes all these states; it may choose to publish only one. I.e., there can be situations where the <a>PWP</a> is only published unpacked (so only the locator of the published unpacked <a>PWP</a> exists), or only published packed (so only that locator exists).
                  </p>
              </li>
          </ul>

          <p>See the section <a href='#identification'></a> for further details on locators and identification.</p>
      </section>

      <section id="pwp_processor">
          <h2>PWP Processor</h2>
          <ul class="definition">
              <li>A <dfn>rendering engine</dfn> has the responsibility of the rendering the contents of a <a>Portable Web Publication</a>. This is, typically, the core rendering engine of a traditional Web Browser, or a dedicated rendering subsystem of a Reading System.</li>

              <li>A <dfn>PWP processor</dfn> is a piece of functionality that has the responsibility of interpreting the specificities of a <a>Portable Web Publication</a>, including mapping <a data-lt="locator">locators</a>, handling a <a>packed</a> state, etc. <strong>On a conceptual level the <a>PWP processor</a> ensures that the <a>rendering engine</a> can consider the content of a <a>Portable Web Publication</a> as if all its resources were available via the <a>state independent locator</a> of the unpacked, protocol <a>PWP</a> </strong> (i.e., with no packaging involved).
              </li>
          </ul>

          <p>See the sections <a href="#arch"></a> and <a href="#locator-pwp-func"></a> for further details on PWP Processors</p>

          </p>
      </section>

      <section id="manifest_definitions">
          <h2>Manifest terms</h2>
          <ul class="definitions">
              <li>A <dfn data-lt="manifest|manifest file" >manifest (file)</dfn> is a special resource containing fundamental information about a <a>PWP</a>. The serialization syntax and the full content of a manifest is not defined in this document. A media type (see [[rfc6838]]) is also associated with a manifest (or a particular serialization thereof), that can be used when a particular instance is retrieved through standard HTTP(S) protocol.</li>

              <li>A <dfn data-lt="manifest item|manifest items">manifest item</dfn> is an information item within the <a>manifest file</a> that can be retrieved by, e.g., a <a>PWP Processor</a>. These may include metadata, information on rendering order and rendition, etc. For the purpose of this document it is important that
              <a>state locators</a>, as well as the <a data-lt="state independent locator">state independent locators</a> can be described as such manifest items, i.e., they can be part of a <a>manifest</a>.</li>

              <li>A <dfn>PWP manifest</dfn> or <dfn>complete manifest</dfn> is a <a>manifest</a> that contains <em class="extra-em">all</em> <a>manifest items</a> that are required by a <a>PWP processor</a>. The complete list of required items are not defined here; for the purpose of this document it suffices to state that the <a>state independent locator</a>, as well as all <a>state locators</a> for all available <a data-lt="state">states</a>, MUST be part of a <a>PWP manifest</a>.</li>

          </ul>
          <p>See <a href="#manifest-details"></a> for further details on manifests.</p>
      </section>
    </section>

    <section id="achieving_convergence">
      <h2>Achieving convergence: technical challenges and draft approaches</h2>

      <p>This section considers some of the technical work areas that should be clarified for a more precise and detailed specification of <a>Portable Web Publications</a>. The list is not exhaustive and there are only hints at the technical solutions without claiming to be complete and tested for validity. It must also be emphasized that some of solutions to the problems listed below may not come from W3C, but possibly from other, external organizations (document identification is a typical example).</p>

      <p>The <a href="#terminology"></a> section provides a conceptual framework for the technical discussion. The most important definition is the one of <a>Portable Web Publications</a>: the fact that a PWP, i.e., a single Web reference, identifies a <em>collection</em> of  <a data-lt="Web Resource">Web Resources</a> that conveys the โboundednessโ which characterizes a publication (e.g. a book or an article). All technical issues in this section are, fundamentally, around the question on how this boundedness should co-exist with the opennes of the Web in general.
      </p>

      <figure id="pwp_one_url" >
        <img src="figures/PWP-oneURL.svg" alt="Image showing a collection of resources, surrounded by a dotted line, and an arrow pointing at that dotted line" style="width:60%">
        <figcaption>A <a>PWP</a> represents a <em>collection</em> of <a data-lt="Web Resource">Web Resources</a> that together form a publication, rather than the individual resources. (Picture is available directly in <a href="figures/PWP-oneURL.svg">SVG</a> or <a href="figures/PWP-oneURL.png">PNG</a> formats.)</figcaption>
      </figure>

      <section id="arch">
        <h3>General Architecture for Portable Web Publications: PWP Processors</h3>

        <p id="abstraction">The role of a <a>PWP Processor</a> is to shield the specificities of handling a PWP from the <a>rendering engine</a>. This <a>rendering engine</a>, typically the core rendering part of a browser, should consider that all content it renders, or it needs for rendering (e.g., CSS or font files) are retrieved from the Web via, typically, HTTP(S) as separate resources. To use the terminology in <a href="#state_definition"></a>, <strong>the <a>rendering engine</a> may consider each PWP as being in an <a>unpacked</a> and <a>protocol</a> state, with all resources available.</strong> A <a>PWP Processor</a> makes it possible to bring <a>Portable Web Publications</a> under the same abstraction as a <a>Web Resource</a> identified by a URL. </p>

        <p>More specifically, a <a>PWP Processor</a> has to achieve several tasks:</p>

        <ul>
            <li>Provide some sort of a local storage, or cache, of the PWP content. Alternatively, it has to have a direct access to content of a PWP if this latter is in a <a>file state</a>. To achieve this, the processor has to catch the HTTP(S) requests stemming from the <a>rendering engine</a> and has to, possibly, serve the content from its cache or the file. In other words, the <a>PWP Processor</a> has to act as a network proxy.</li>

            <li>Take care, if necessary, of unpacking the content of a PWP on the fly if this latter is in a <a>packed state</a>. This, combined with a local cache, means that the <a>rendering engine</a> is oblivious to the <a>state</a> of the PWP.</a></li>

            <li>Take care of the conversion of <a data-lt="locator">locators</a> to the consituent resources of a PWP, possibly convert from locators provided via <a>state locators</a> or a <a>state independent locator</a>: the differences among these different locators should become transparent to the <a>rendering engine</a>. See <a href="#locator-pwp-func"></a> for further details.
        </ul>

        <figure style="text-align: center;" id="workers_basic">
          <img src="figures/Workers-basic.png" alt="A laptop computer gaining access to the unpackaged publication from a web browser connecting to a Server with HTTP requests." style="width:80%">
          <figcaption>Accessing a <a>Portable Web Publication</a> in an <a>unpacked</a> state directly from the Web. (Picture is available directly in <a href="figures/Workers-basic.svg">SVG</a> or <a href="figures/Workers-basic.png">PNG</a> formats.)</figcaption>
        </figure>

        <figure style="text-align: center;" id="workers_package">
          <img src="figures/Workers-package.png" alt="A laptop computer gaining access to the packaged publication from a web browser connecting to a Server via service workers." style="width:80%">
          <figcaption>Accessing a <a>Portable Web Publication</a> in <a>packed</a> state from the Web via a PWP Processor. (Picture is available directly in <a href="figures/Workers-package.svg">SVG</a> or <a href="figures/Workers-package.png">PNG</a> formats.)</figcaption>
        </figure>

        <p id="sworkers" class="note">The latest evolution of browser technologies around Web Workers&nbsp;[[web-workers]] and Service Workers&nbsp;[[service-workers]] make the development of a <a>PWP Processor</a> feasible. Service Workers will provide a flexible and programmable way to efficiently implement local caching of <a data-lt="Web Resource">Web Resources</a>. Caching is implemented as a programmable network proxy, meaning that the browserโs rendering engine becomes oblivious to whether a resource originates from the local cache or directly from the network: these are indeed some of the basic functionalities a <a>PWP Processor</a> must provide.  </p>
      </section>

      <section id="identification">
        <h3>Addressing and Identification</h3>

        <p>HTTP(S) URLs serve as the fundamental method for addressing a resource, or a fragment thereof, on the Web. Such URLs can also be used to uniquely identify a resource; however, conceptually, <em class="extra-em">the role of addressing and identification are different</em>. <em>Both</em> of these functionalities should be available for <a>Portable Web Publications</a>: a publication should be uniquely identified for, e.g., library catalogues or archival, and a resource locator should be available so that the user could access the content. In other words, a <a>Web Publication</a> (whether portable or not) SHOULD have both one or even possibly several <em>identifier(s)</em> and one <em>locator</em>. These may be be identical but may also be different: e.g., an identifier may refer to a specific publication by a publisher (e.g., using an <a href="https://www.isbn-international.org/">ISBN</a>), whereas the locator may refer to a personal copy of that publication that the owner can freely annotate for personal use.</p>

        <p class="note">A typical use case for the presence of an <em>identifier</em> beyond the need for a <em>locator</em> is in academic and scholarly publishing. There are currently several methods for citing online works, but there is no equivalent standard method for citations to ebooks. Even if a reflowable ebook is cited by a scholar, the author must refer to the PDF, paper copy, or HTML version to cite it in her bibliography. Identifiers attached to <a>Portable Web Publications</a> should enable stable citations.</p>

        <p>A general [[URI]] (which includes the notion of [[URL]]) MAY serve as an <em>identifier</em> using, e.g., the [[ISBN-URN]] or [[UUID]] schemes. But an identifier does not necessarily resolve to a location on the Web, although it is a good practice to have a dereferencable identifier.</p>

        <p> There is no  ubiquitously accepted method for identifying a publication among the various document formats (whether electronic or printed). Within the scholarly publishing industry, for example, initiatives such as <a href="http://www.doi.org">DOI</a> and <a href="http://crossref.org">CROSSREF</a> have addressed this problem, whereas traditional โtradeโ publishing rely more on <a href="https://www.isbn-international.org/">ISBN</a> related services. Some of these identifier schemes provide resolver services or a โstandardโ representation in term of [[URL]]. <em>The definition of <a>Portable Web Publication</a> should be oblivious to the exact identification used; this issue is left to specialized services and industry organizations.</em> Architecturally, the only requirement, regarding identifiers, is that the <a>complete manifest</a> of a  <a>Portable Web Publication</a> MUST include a <a>manifest item</a> for one, or more, identifiers, and that these should be stable across, for example, copying the publication or changing its location on the Web. This document concentrates on addressing only, i.e., on the management of <a data-lt="locator">locators</a>.</p>

        <div class="issue" data-number="12">Do we need a more general form of identification to represent fragments?</div>

        <div class="issue"><a href="https://github.com/w3c/dpub-pwp-loc/issues/28">Issue 28 on Locators</a>: do we need several, possibly a hierarchy of identifiers? The current discussion converges towards a model whereby a PWP may have
            <ol>
                <li>A set of identifiers (with possibly a label assigned to each identifier to describe what it is for and who is the authority to assign them)</li>
                <li>A state independent locator (can we call this a 'state independent locator'?)</li>
                <li>State specific locators of a particular copy (ie, a locator to my copy in zip, and a separate locator to the unpacked version on my server)</li>
            </ol>
            <p>
                The rule being that the entries in (1) SHOULD be changed only by the respective authorities, and they MUST be part of the PWP manifest.
            </p>
        </div>

        <section id="locator-pwp-func">
            <h2>Locators functionalities of PWP Processors</h2>

            <p>A <a>PWP</a> is published on the <a>server</a>. This <a>PWP</a> includes, e.g., the resource for an image, and is published in at least one of the different states:
            </p>

            <ul>
                <li>In an <a>unpacked</a> state. The โtop levelโ of this unpacked state is available, say, through the URL <code>https://example.org/books/1/</code>: in this setup, the URL of the image is, say, <code>https://example.org/books/1/img/mona_lisa.jpg</code>. This is the <a>absolute locator</a> of the image <em>in this state</em>.
                </li>

                <li>In a <a>packed</a> state. This is available through the URL, say, <code>https://example.org/packed-books/1/package.zip</code>. This is the <a>absolute locator</a> of the <a>PWP</a> <em>in this state</em>, and the locator for the image depends on the structure of the package format.
                </li>
            </ul>

            <p>The published <a>PWP</a> is also assigned a <a>state independent locator</a>, e.g., the URL <code>https://example.org/published-books/1</code>. Reflecting the unpacked state in terms of (file) structure the <a>state independent locator</a> of the same image is <code>https://example.org/published-books/1/img/mona_lisa.jpg</code>.
            </p>

            <p>To ensure the smooth transtion among states (see <a href="#arch"></a>) the <a>PWP Processor</a> must ensure a smooth transition among the different locators of any resource within a <a>PWP</a> (the image file in this example). </p>

            <p class="note">From a user/author point of view, whenever possible, the <a>state independent locator</a> should be used when referring to the <a>PWP</a> in, e.g., annotations. This is also true for URL-s derived from the <a>state independent locator</a>, like <code>https://example.org/published-books/1/img/mona_lisa.jpg</code>. This means the addressing unequivocal; however, a <a>PWP Processor</a> must be prepared for the more general case.
            </p>

            <p>In view of the above, the functionalities of the <a>PWP processor</a> can be divided into two steps:</p>
            <ol>
                <li>finding, based on the <a>state independent locator</a>, the right values of the various <a>state locators</a></li>
                <li>extract, based on a specific <a>state locator</a>, the exact locators for additional, internal resources</li>
            </ol>

            <p>This functionality is based on the requirement that the <a>complete manifest</a> of a PWP MUST include both the <a>state independent locator</a> as well as all available <a>state locators</a>. Consequently, in order to retrieve the <a>state locators</a>, the PWP must first retrieve the <a>PWP manifest</a> using the <a data-lt="state independent locator">state independent locator</a>. (See the separate section <a href="#manifest-details"></a> on the details of the <a>complete manifest</a> retrieval.) Once the <a>complete manifest</a> is available a resource within a PWP can be retrieved by first deriving the <a>relative locator</a> for a resource (e.g., <code>img/mona_lisa.jpg</code>) and then combining it with the <a>absolute locator</a> corresponding to the <a>state</a> of the PWP as referred to by the <a>rendering engine</a>.</p>

            <p class="note">There may be โsmarterโ <a data-lt="PWP processor">PWP Processors</a> that make use of local facilities like caching, but those do not modify these conceptual approaches.
            </p>
        </section>

        <section id="breadcrumbs">
            <h2>Breadcrumbs</h2>

            <p>A different problem, related to locators (and possibly identifiers) is to record changes when a specific <a>PWP</a> is copied, re-published, etc. Handling this โhistoryโ is particularly important if an existing <a>PWP</a> cannot be altered, i.e., it is only possible to create a <em>new</em> <a>PWP</a> that is derived from an existing <a>PWP</a>.</p>

            <p>Tha approach that can be taken is to store, in the <a>complete manifest</a> of the PWP, a โbreadcrumbโ, i.e., a list of (state independent) <a data-lt="locator">locators</a>, and possibly a list of identifiers, as specific <a date-lt="manifest item">manifest items</a>. Because the creation of the <a>complete manifest</a> is based on an algorithm that includes the <a>combination of manifests</a>, a proper <a>server</a> setup may provide such an information even if the original publication cannot be altered. A <a>PWP Processor</a> can make use of this breadcrumb information to reference various instances and addresses of the history of the current <a>PWP</a>.</p>

            <div class="note">
                <p>To take a specific example, let us consider a <a>PWP</a>, denoted as <code>P</code> and with <a>state independent locator</a> <code>L</code>. This is the copy of the publication used by a teacher, to which he/she may have added a number of annotations. Using an ad-hoc syntax, the <a>complete manifest</a> of <code>P</code> contains <code>stateIndependent:&nbsp;L, breadcrumbs:&nbsp;[]</code>.</p>

                <p><code>P</code> might be published at the school of the teacher, under <code>https://example.org/course/french/frenchbook</code> (and thus with a different <a>state independent locator</a>, e.g., <code>L'</code>). This is, conceptually, a new <a>PWP</a> (<code>P'</code>), with a <a>manifest</a> that contains <code>stateIndependent:&nbsp;L', breadcrumbs:&nbsp;[L]</code>.
                </p>

                <p>A student may then again copy <code>P'</code> to her own web space to make her own annotations, yielding <code>P''</code> under <code>https://example.org/student/1/frenchbook</code> as a locator <code>L''</code>. The manifest of <code>P''</code> will thus contain <code>stateIndependent:&nbsp;L'', breadcrumbs:&nbsp;[L,&nbsp;L']</code>.
                </p>

                <p>References to <code>P</code> or <code>P'</code> might be interpreted by a <a>PWP processor</a> for <code>P''</code> to, for example, link back to the original <code>L</code> and locate, if necessary, the annotations originally prepared by the teacher.
                </p>
            </div>
        </section>
      </section>

      <section id="manifest-details">
        <h3>PWP Manifests</h3>

        <p>The <a>manifest</a> of <a>Portable Web Publications</a> is a <a>Web Resource</a> that includes information pertaining to the overall publication structure, such as the default logical reading order(s) of the set of resources that comprise the publication (the โspineโ), as well as predictable user-facing meta-structures, such as one or several tables of contents, glossaries, etc. As described in the section <a href="#identification"></a>, the <a>manifest</a> also provides the necessary information to address the different <a data-lt="state">states</a> of a <a>PWP</a>. Finally, the <a>PWP manifest</a> may also include various metadata (either directly or via further references) that are essential for the overall publishing workflow. The exact definition of all possible <a data-lt="manifest item">manifest items</a>, the internal structure and serialization syntax of a <a>manifest</a>, etc., will require additional work as part of a more detailed specification of <a>Portable Web Publications</a>. However, based on the general architectural approach outlined in this document, it is already expected that the <a>complete manifest</a> of a PWP MUST include the <a>state independent locator</a>, all available <a>state locators</a>, as well as the identifiers of the PWP instance.</p>

        <p>A fundamental question that must be answered is how does a <a>PWP Processor</a> get hold of the <a>complete manifest</a> if only the <a>state independent locator</a> is known. Because the publication patterns of PWP-s can be different, depending on publishers, authors, etc., there should be different ways of accessing the manifests: it can be referred to via a <code>link</code> element in an HTML file, can be in an agreed-upon-position within a package, or can be conveyed through a <code>LINK</code> header of an <code>HTTP(S)</code> request. The PWP Processor gets hold of the <a>complete manifest</a> by following a hierarchy of these different possibilities; a separate <a href="#simple-manifest-access">section</a> in the appendix provides more details. (Note that accessing a manifest also has some security issues; the <a href="https://w3c.github.io/manifest/#obtaining">โObtaining a manifestโ</a> of the โWeb App Manifestโ&nbsp;[[web-manifest]] document provides some further details that could be adopted, too.)

        <p> This algorithm is typically performed by the <a>PWP Processor</a> when initialized with the state independent locator of a particular <a>PWP</a> instance.</p>

        <p>The โWeb App Manifestโ&nbsp;[[web-manifest]], currently developed at W3C, is one example of a technology that could be used, or adopted, to define the final formats for PWP manifests. Although the current&nbsp;[[web-manifest]] drafts is geared towards Web Applications, it also includes extension points to define further manifest items necessary for PWP. Some of these extra manifest items have been already explored within the framework of the <a href="https://github.com/dauwhe/epub31-bff">โBrowser Friendly Manifestationโ</a> work of the EPUB3.1 Working Group at the IDPF.
        </p>

        <aside class="issue" data-number=22 title="Is it necessary to have the concept of manifest combination?">
            There is a <a href="https://w3c.github.io/dpub-pwp-ucr/index.html#h-there-should-be-a-possibility-to-combine-manifests-from-several-origins">use case documented in the PWP UCR document</a> which refers to the possibility of <em>combining</em> manifest coming from different origins, instead adopting the simple approach of taking the first available manifest. This approach, which leads to significant complications, is further explored in the <a href="#complex-manifest-access">separate Appendix</a> below.
        </aside>
      </section>

      <section id="metadata">
        <h3>Metadata: discovery</h3>
        <p>Throughout the digital publishing industry, highly specialized metadata vocabularies, and serialization forms thereof, are being used. Within book trade publishing as an example, ONIX&nbsp;[[ONIX]] has attained a dominant status as a metadata package that typically exists (in XML form) independently of the publication, and contains not only bibliographic metadata, but also trade information such as pricing. Scholarly publishing, on the other hand, often uses various derivatives of the ubiquitous BibTeX vocabulary.</p>

        <p>While not contradicting the obvious use cases for out-of-line metadata records as used by publishers, retailers and libraries, <a>Portable Web Publications</a> must define a syntax for basic in-line metadata records that is agnostic to the publicationโs states. This means that the syntax must seamlessly support discovery and harvesting by both generic Web search engines, as well as dedicated bibliographic/archival/retailer systems. While it is expected that <a>Portable Web Publications</a> will define a minimal set of required metadata (cf. the section <a href="#identification"></a>), development and adoption of other vocabularies in <a>Portable Web Publications</a> will most likely be deemed as out of scope. In other words, domain-specific metadata requirements are up to the domains themselves to define via a profiling mechanism, or similar yet-to-be-defined means. </p>

        <p class="note">The adoption of HTML as the vehicle for expressing publication-level metadata (i.e., using RDFa&nbsp;[[html-rdfa]] and/or Microdata&nbsp;[[microdata]] for metadata, like authors or title) would have the added benefits of better I18N support than XML or JSON formats.</p>
      </section>

      <section id="package">
        <h4>Archive formats</h4>

        <p>Regardless of the details of the practical architecture realizing <a>Portable Web Publications</a>, an archive format is necessary for the storage of a publication as one file (e.g., for distribution or possibly archiving) defined as the <a>packed</a> state of a <a>Portable Web Publication</a>. A variety of formats for offline/archival storage of collections of digital resources exist today (e.g., [[OCF]], [[ODF]], and [[OOXML]]), but none of them is universally recognized and supported across all ecosystems. Depending on the general architecture, <a>Portable Web Publications</a> may use one of the deployed formats (e.g., the current EPUB packaging format based on [[OCF]]), or an archive format that is generic and native to the Open Web Platform. </p>

        <p>W3Cโs <a href="http://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a> has published a Working Draft for a Streamable Package Format for the Web&nbsp;[[web-packaging]] to encompass the needs of various applications (like installing Web Applications or downloading data for local processing). It is not clear at this moment whether browsers will adopt this format, though. </p>

        <p>However, the importance of streaming is not paramount for <a>Portable Web Publications</a>. Indeed, the same publication may be accessed by the same user from different clients; if some user-dependent management also keeps track of the latest reading position in the publication, switching from one client to the other may mean that a client would have to โjumpโ <em>into</em> the content, thereby bypassing streaming. Nevertheless, if browsers, eventually, do converge towards a browser and streaming friendly packaging format, adopting it for <a>Portable Web Publications</a> may become a real alternative. The community will have to balance native browser availability against the the wide availibility of tooling and industry distribution based on [[OCF]].</p>

        <div class="note">
          <p>The IETF has published an <a href="https://tools.ietf.org/html/draft-seantek-kerwin-arcmedia-type-01">informational draft on a top-level media type for archives</a>. Although that draft does not specify a specific archive format, and the work is currently on hold, it shows the overall interest in packaging on the Web in line with the concerns of <a>Portable Web Publications</a>.</p>
        </div>
      </section>

      <section id="styling">
        <h3>Styling and Layout, Pagination</h3>
        <p>As outlined in [[dpub-latinreq]] or [[dpub-css-priorities]], the Open Web Platform in general, and CSS in particular, is still lacking solutions for meeting all of the publishersโ expectations on satisfactory typography and layout for digital publications. While improved presentation fidelity will be of paramount importance to the overall success and adoption rate of <a>Portable Web Publications</a>, it is clear that many of these issues are going to be addressed on a case-by-case basis by the CSS Working Group over a longer period of time. STM publishing, for example, where the faithful representation and rendering of, say, mathematical or chemical formulae is of a paramount importance, has particularly severe requirements that must be fulfilled by the Open Web Platform technologies. Similarly, dynamic pagination of reflowable content is not natively supported by browsers today, and as a result Reading System developers, for example, are forced to implement pagination using various ad-hoc approaches, all coming with a significant penalty in terms of development costs, performance and stability.</p>

        <p>It is anticipated that native support for pagination (in CSS and/or in the DOM) is going to be put forward by stakeholders as a critical component of <a>Portable Web Publications</a>; thus the finalization of <a>Portable Web Publications</a> may be contingent on the availability of a native pagination model for Web content.</p>

        <p class="note">Note that the <a href="https://wiki.css-houdini.org/">โHoudiniโ Task Force</a>, recently started jointly by the W3C CSS WG and the W3C TAG, may open new avenues to handle pagination.</p>
      </section>

      <section id="security_models">
        <h3>Security Models</h3>

        <p>The security model of the Web, based primarily on the same-origin policy and the concept of โsiteโ, does not apply to portable documents, as the notion of โoriginโ is based on HTTP properties that are invalidated/non-existent when a document transitions from its online state to the portable state. Portable Web Publications must incorporate a state agnostic security model that defines rules for both the online and portable states.</p>
      </section>

      <section id="personalization">
        <h3>Presentation Control and Personalization</h3>

        <p>When reading long-form (and sometimes mission-critical) publications, personalizationโi.e., the ability for users to adapt the presentation to suit their needsโis of a great importance. While technologies such as CSS Media Queries have come a long way in terms of adapting content to devices, this is not the same thing as adapting to a user. Presentation control features are often available in e-book readers of different kinds, for example the possibility to dynamically change font size or background/foreground color schemes, but implementations are brittle and limited due to the lack of an underlying framework that explicitly supports user adaptation.</p>

        <p><a>Portable Web Publications</a> needs to incorporate an explicit framework for achieving advanced and predictable user-triggered presentation control. (Note that from this perspective, accessibility can be seen just a radical case of personalization.)</p>
      </section>

      <section id="domain_specific_restrictions_extensions">
        <h3>Models for embracing domain-specific restrictions and extensions</h3>

        <p>Different domains of digital publishing have vastly different expectations and/or requirements on the nature of the content and their presentation. In the digital comics domain for example, the default presentation form is, traditionally at least, pre-paginated, fixed-form, and image-based, possibly with a set of omnipresent (i.e., cross-publisher) user interaction patterns that are expected to be enabled. On the other hand, for trade publishing the default form is fully reflowable content, where user interaction patterns are defined entirely by the user agent. In educational publishing, the ability to control structure, to include rich domain-specific structural semantics and extensive specialized metadata, are at the basis for enhanced reading system behaviors, as well as predictable content discovery and repurposing. </p>

        <p>To allow for the predictability of content within those domains that need it, <a>Portable Web Publications</a> may need to incorporate a notion of โprofilesโ that content can be authored and validated against, and that user agent implementations can use to trigger enhanced behaviors, if any. To allow for agile feature-set extensions and innovation, <a>Portable Web Publications</a> profiles also needs to embrace the notion of โfeature addonsโ that can be included by a publisher without risking to invalidate the integrity and functionality of the basic publication.</p>
      </section>
    </section>

    <section id="epub-relations">
      <h2>Portable Web Publications and EPUB&nbsp;3</h2>

      <aside class="annotation">
          This paragraph may have to be rewritten as the discussions with IDPF progress.
      </aside>
      <p>The development of the definitions of <a>Portable Web Publications</a> should not be made in isolation, given the diverse publishing ecosystems that already exist. Rather, the development should rely as much as possible on existing and deployed formats, which include both the various Open Web Platform technologies and digital publishing formats.</p>

      <p>Several document formats exist in the digital publishing domain; however, the only vendor independent and HTML based format is EPUB&nbsp;3&nbsp;[[EPUB3]], which emphasizes a dynamic determination of content presentation and a closer alignment with the Open Web Platform.  EPUB&nbsp;3 is built on Web Standards, and the individual items that make up an EPUB publication are identical to types of content on a Web site: [[html5]], [[svg]], [[css21]], [[ECMAScript]], [[JPEG]] and [[png]] images, etc. Various browser extensions supporting EPUB exist (e.g., <a href="https://chrome.google.com/webstore/detail/readium/fepbnnnkkadjhjahcafoaglimekefifl">Readium in Chrome</a>, <a href="http://www.epubread.com/en/">EPUBReader</a> in Firefox). Other solutions exist for delivering these files in browsers (<a href="http://readium.org/">Readium-Cloud</a>, <a href="https://github.com/futurepress/epub.js/">EPUB.js</a>, <a href="https://www.safaribooksonline.com/">Safari Books Online</a>, etc.). Publishers are actively exploring the new and possibly interactive possibilities offered by EPUB&nbsp;3; a good example is <a href="http://bcs.wiley.com/he-bcs/Books?action=index&bcsId=7005&itemId=1118087887">Cay Horstmannโs โBig Java, Late Objectsโ</a>&nbsp;[[BigJava]] that combines the feel of a traditional book with interactive learning materials that makes it reminiscent of similar, Web based tutorials (see the <a href="http://www.wiley.com/college/sc/horstmann/">video</a> on a companion page for the book)</p>

      <p>Whilst the concept of <a>Portable Web Publication</a> is close to, and has been inspired by, EPUB&nbsp;3, it goes beyond it, insofar as it emphasizes the need for a convergence between the offline and online usages. It would be highly desirable to deliver on the requirements on <a>Portable Web Publications</a> in an evolutionary manner that would build on, and would be backwards compatible with, existing EPUB&nbsp;3, since the latter is already widely deployed. However, this may not be possible. At this stage, this document emphasizes all requirements envisioned for <a>Portable Web Publications</a> without addressing the natural tension between goals of preserving compatibility and fully achieving all these requirements in the most elegant manner. But neither this end-goal emphasis, nor the use of the new term โ<a>Portable Web Publication</a>โ, should be taken as implying a recommendation to definitely create a completely new format that would replace EPUB. Further investigation is required, and the ongoing evolutionary trajectory of EPUB&nbsp;3 must also be taken into account.</p>

      <p class="note">The current evolution of EPUB&nbsp;3 towards EPUB&nbsp;3.1 will address several compatibility and convergence issues with the Open Web Platform; this will make the evolution path towards <a>Portable Web Publications</a> easier.</p>

      <p>It must also be emphasized that the central part of any EPUB&nbsp;3 publication, namely the <em>content</em>, will remain unchanged or will require only minimal changes when transitioning towards <a>Portable Web Publications</a>. The bulk of the changes are expected to occur around the accompanying constructs like publication-level metadata records, the spine, or the packaging format of the content. As described in the section <a href="#pwp_definition"></a>, the content of a <a>Portable Web Publication</a> is based on core <a href="https://www.w3.org/wiki/Open_Web_Platform">Open Web Platform</a> technologies including [[html5]], [[svg]], or [[css21]], and other types of files like images, audio and video, metadata files, or executable code. Most of these are valid contents in EPUB&nbsp;3 already; a transition towards <a>Portable Web Publications</a> will leave these resources and their usage intact. The envisaged changes will be mostly restricted to the implementation details of reading systems and production workflows. The evolution of the past few years of online tooling for the production of EPUB content based on the Open Web Platform (e.g., the platforms developed and used by companies like OโReilly, Hachette, Metrodigi, or Inkling) will also greatly facilitate any transition to <a>Portable Web Publications</a>; adapting these tools is expected to be quite straightforward.
      </p>
    </section>

    <section id="conclusion">
      <h2>Conclusions</h2>
      <p>This document outlines a vision for the convergence between the Open Web Platform and portable documents while also significantly advancing and expanding the existing digital publishing ecosystem. The realization of this vision would require a strong cooperation between the traditional publishing and Web communities, based on a close collaboration between the W3C and other relevant organizations, like <a href="http://idpf.org">IDPF</a>, <a href="http://editeur.org/">EDItEUR</a>, <a href="http://www.bisg.org">BISG</a>, or others. While it is envisaged that most of the work could be done in one or more dedicated Working Groups (within W3C or elsewhere, depending on the exact charter), it must be emphasized that many of the features will affect and will be affected by work done elsewhere, within or outside these organizations. The starting point will be to explore and plan for the detailed technical challenges to gain a better insight into the work ahead; this exploration should be done together with the various interested communities.
      </p>
    </section>

    <section class="appendix" id="simple-manifest-access">
        <h2>Algorithm to retrieve the manifest for a PWP</h2>

        <p>The goal of this algorithm is to obtain the <a>PWP manifest</a> based on the value of the <a>state independent locator</a> <strong>L</strong>. This algorithm is performed by the <a>PWP Processor</a>, typically when it is initialized with the state independent locator <strong>L</strong> of a particular <a>PWP</a> instance. The algorithm retrieves the <a>PWP manifest</a> based on the HTTP(S) responses on a <code>HTTP GET</code> request on <strong>L</strong>.</p>

        <p class="note">
            If the <a>PWP processor</a> already has the cached publication, than that will probably prevail (modulo cache state) and there may be no HTTP request in the first place. This section really refers to the situation of a first access.
        </p>

        <p>In what follows, as an abuse of notation, <code>HTTP&nbsp;GET&nbsp;U</code>, for a URL <code>U</code>, refers to an <code>HTTP</code> or <code>HTTPS</code> request issued to the domain part of <code>U</code>, using the path from <code>U</code>. I.e., if <code>U</code> is <code>http://www.ex.org/a/b/c</code>, then <code>HTTP&nbsp;GET&nbsp;U</code> stands for:</p>

        <pre><code>GET /a/b/c HTTP/1.1
Host: www.ex.org</code></pre>

        <p>See [[rfc2616]] for further details.</p>

        <p>With these prerequisites, the algorithm is as follows (see also <a href="#fig-flow-get-1">the figure</a> as a visual aid to the algorithm). The input to the algorithm is the <a>state independent locator</a> of the <a>PWP</a> instance, <strong>L</strong>.</p>

        <ol class="algorithm" id="simple_algorithm">
            <li>Issue an <code>HTTP&nbsp;GET&nbsp;L</code> request, possibly returning the message body <strong>B</strong>.</li>

            <li>If the response is not successful (e.g., the response code is a 404), the process fails with no results.</li>

            <li>Otherwise, consider the HTTP Response headers:
                <ol>
                    <li>If the headers include an entry of the form  <code>LINK&nbsp;&lt;URI&gt;;&nbsp;rel="pwp_manifest"</code> (see [[rfc5988]]) then issue an <code>HTTP&nbsp;GET&nbsp;URI</code> request. </li>

                    <li>If that response is successful, the algorithm stops by returning the response message body to the caller as the <a>PWP manifest</a>.</li>

                    <li>(Otherwise, the algorithm continues.)</li>
                </ol>
            </li>
            <li>Consider the media type of the original message body <strong>B</strong>. If it is:
                <ol>
                    <li>A <em>manifest</em>, as identified by its media type (to be defined), the algorithm stops by returning the response content <strong>B</strong> to the caller as the <a>PWP manifest</a>.</li>

                    <li>A <em>packaged PWP instance</em> (identified via the media type to be specified for the packed <a>state</a> of a PWP):
                        <ol>
                            <li>Unpack the package, and retrieve the <a>manifest</a> embedded in the package as (to be) specified by the packed state of a PWP.</li>
                            <li>The algorithm stops by returning the manifest retrieved from the package to the caller as the <a>PWP manifest</a></li>
                        </ol>
                    </li>

                    <li>An <em>HTML document</em>, then
                        <ol>
                            <li>If the HTML content includes a <a>manifest</a> content embedded in a <code>&lt;script&gt;</code> element, serialized in to one of the accepted serializations for PWP manifests:
                                <ol>
                                    <li>Retrieve and parse the content of the <code>&lt;script&gt;</code> element.</li>
                                    <li>If parsing is successful, the algorithm stops by returning the parsed manifest content to the caller as the <a>PWP manifest</a>.</li>
                                    <li>Otherwise, the algorithm continues</li>
                                </ol>
                            </li>
                            <li>If the HTML content includes a <code>&lt;link&nbsp;rel="pwp_manifest"&nbsp;href="URI"&gt;</code> in the header:
                                <ol>
                                    <li>Issue a <code>HTTP&nbsp;GET&nbsp;URI</code> request</li>
                                    <li>If the response is successful, the algorithm stops by returning the response message body to the caller as the <a>PWP manifest</a>.</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>If the algorithm gets to this points, it fails with no results.</li>
        </ol>

        <ul class="note" id="man_alg_notes">

            <li>The algorithm considers only HTML as a possible non-packaged and non-manifest response format. It may become possible to allow, for example, SVG as another, possible format for a <a>PWP</a>; this depends on the final specification of a PWP. The algorithm should then be adapted accordingly by adding a relevant branch (e.g., the specification of SVG includes <code>&lt;script&gt;</code> element that can be used to embed a manifest, but does not have a <code>&lt;link&gt;</code> element).</li>

            <li>It may be possible for HTML file to includes several <code>&lt;link&gt;</code> elements referring to a <a>manifest</a> each. If that becomes allowed by a PWP specification, the corresponding step could be modified by taking all link elements into account, and sequentially considering the manifest files in document order to yield the manifest. The same note is valid for several <code>&lt;script&gt;</code> elements.</li>

            <li>Similarly, if a PWP specification allows for several different serialization syntaxes for manifests, the processor should be able to recognize and parse them accordingly. The expectation is that the various possible serializations MUST serialize the <em>same</em> content, i.e., these do not influence the final result.</li>

            <li>The algorithm is silent on the details on how a manifest should be retrieved from a package. This depends on the detailed specification of packaging, on whether a manifest would have to be at a known location within a package, on whether there might be several manifest instances within a package, etc. It is also possible that the details would follow a similar approach as described in this algorithm, i.e., relying on embedded and linked manifests of a top level HTML file, for example. As far as the algorithm described in this section is concerned, these details do not influence the final result.</li>

            <li>The algorithm makes use of the constant <code>pwp_manifest</code>; the exact value of this constant must be defined, and registered, through a more precise specification of PWP-s. It is used here for illustrative purpose only.</li>

            <li>The PWP Processor MAY include an <code>Accept</code> header (see [[rfc7231]]) when issuing a <code>HTTP GET</code> to express its preference for, e.g., a packed state of a PWP over manifest payload, or in favor of a particular serialization of the manifest content. Whether this is done or not, and whether the server honors this preference, does not influence the details of the algorithm.</li>
        </ul>


        <figure id="fig-flow-get-l">
            <img src="figures/Simple_manifest_access.svg" width="100%" alt="Flowchart of what happens when a Portable Web Publication is retrieved by the user and how this leads to the PWP manifest; manifest are not combined, first one is used" longdesc="#algorithm"/>
            <figcaption>Visual representation of the simple <a href="#simple_algorithm">algorithm</a> to retrieve the <a>PWP manifest</a>. The figure is also available in <a href="figures/Simple_manifest_access.svg">SVG</a> and <a href="figures/Simple_manifest_access.png">PNG</a> formats.</figcaption>
        </figure>
    </section>

    <section class="appendix" id="acknowledgements">
        <h2>Acknowledgements</h2>
        <p>The following people have been instrumental in providing thoughts, feedback, reviews, content, criticism, and input in the creation of this document:</p>

        <div style="margin-left: 3em">
            Boris Anthony (Rebus Foundation), Luc Audrain (Hachette Livre), Nick Barreto (Invited Expert), Baldur Bjarnason (Rebus Foundation), Timothy Cole (University of Illinois at Urbana-Champaign), Garth Conboy (Google), Dave Cramer (Hachette Livre), Romain Deltour (DAISY Consortium), Brady Duga (Google), Heather Flanagan (Invited Expert), Markus Gylling (IDPF), Ivan Herman (W3C), Deborah Kaplan (Invited Expert), Bill Kasdorf (BISG), George Kerscher (DAISY Consortium), Peter Krautzberger (Invited Expert), Charles LaPierre (Benetech), Laurent Le Meur (EDRLab), Vladimir Levantovsky (Monotype), Mia Lipner (Pearson), Christofer Maden (University of Illinois at Urbana-Champaign), Shane McCarron (Spec-Ops), William McCoy (IDPF), Hugh McGuire (Rebus Foundation), Ben De Meester (iMinds), Liam Quin (W3C), Leonard Rosenthol (Adobe), Nicholas Ruffilo (Invited Expert), Rob Sanderson (Stanford University), Avneesh Singh (DAISY Consortium), Alan Stearns (Adobe), Ayla Stein (University of Illinois at Urbana-Champaign), Tzviya Siegman (Wiley), Ralph Swick (W3C), Nicholas Taylor (Stanford University), Benjamin Young (Wiley), and Daniel Weck (DAISY Consortium)
        </div>

        <!--
        <p>
            The following people, besides the editors, have made editorial contributions to the document:
        </p>
        <div style="margin-left: 3em" id="gh-contributors">

        </div>
    -->
    </section>

    <section class="appendix" id="complex-manifest-access">
        <h2>Combination of manifests</h2>
        <p>There is an <a href="https://github.com/w3c/dpub-pwp/issues/22">open issue</a> on whether a PWP processor should be prepared to <em>combine</em> manifests coming from different sources. The main reason for considering this is that the usage patterns of Portable Web Publications involves the possibility of copying and/or re-publishing the publications (e.g., a copy is created for library lending, copies are made for students in a class, etc.). Not all users involved in these operations have the possibility, access, or indeed the skill of modifying the manifests if, for example, they are incorporated into a PWP in a <a>packed</a> state. As a consequence, a <a>complete manifest</a> may have to be combined from different pieces: some <a data-lt="manifest item">manifest items</a> may be part of the PWP as stored on a <a>server</a> (e.g., basic metadata like author or title), while other items may have to be provided by the <a>server</a> itself (e.g., the locators) possibly without changing the PWP itself.
        </p>

        <p>One possibility is that each user makes a <em>copy</em> of an existing manifest to then modify it and make it available to the PWP Processor. Another, more flexible approach is that the <a>PWP Processor</a> is prepared to <em>gather</em> the <a data-lt="manifest item">manifest items</a> from several possible sources, i.e., from several different <a data-lt="manifest">manifests</a>, which are then <a data-lt="combination of manifests">combined</a> through a well-specified algorithm. The essential steps of the retrieval and combination process are based on the following additional terminology:</p>

        <ul>
            <li>The <dfn>combination of manifests</dfn>, denoted by the&nbsp;โ&nbsp;operation (as in <strong>M</strong>&nbsp;=&nbsp;<strong>M<sub>a</sub></strong>&nbsp;โ&nbsp;<strong>M<sub>b</sub></strong>) is the creation of a new <a>manifest</a>, consisting of <a>manifest items</a> originating from <strong>M<sub>a</sub></strong> and <strong>M<sub>b</sub></strong>.

                <p>The precise definition of a <a>manifest</a> should also specify how different <a>manifest items</a> are combined during this operation. For the purpose of this document it is only required, that:</p>
                <ul>
                    <li>the value of <strong>L</strong> MUST be identical, if present, in both <strong>M<sub>a</sub></strong> and <strong>M<sub>b</sub></strong>; and</li>

                    <li>the value of <strong>L<sub>u</sub></strong> (resp. <strong>L<sub>p</sub></strong>) in <strong>M<sub>b</sub></strong> MUST have a higher priority. I.e., if present in <strong>M<sub>b</sub></strong>, this is the value added to <strong>M</strong>, regardless of whether a similar value is also specified in <strong>M<sub>a</sub></strong> or not.</li>
                </ul>
            </li>
        </ul>

        <p>
            Using this terminology, the high level description of the steps is as follows:
        </p>

        <ol>
            <li>The <a>PWP Processor</a> issues a <code>HTTP GET</code> request using the value of the <a>state independent locator</a>.</li>

            <li>Depending on the type of the returned resource, an initial value for the <a>PWP manifest</a> is established. The simplest case is when the returned resource is itself a <a data-lt="manifest">manifest;</a> otherwise the <a>PWP manifest</a> has to be extracted from the returned payload by possibly <a data-lt="combination of manifests">combining</a> manifests of different origins.</li>

            <li>Furthermore, the response header of the <code>HTTP</code> request may also refer to another, different, <a>manifest</a>. If so, this is <a data-lt="combination of manifests">combined</a> with the manifest retrieved from the payload in the previous step, yielding the final <a>PWP manifest</a>.</li>
        </ol>

        <p> This algorithm is typically performed by the <a>PWP Processor</a> when initialized with the state independent locator of a particular <a>PWP</a> instance.</p>

        <p>An important feature of the algorithm (see the <a href="#comples_manifest_algorithm">section below for the details</a> for the details) is that it defines a priority for the various <a data-lt="manifest item">manifest items</a>, e.g.,the <a>state locators</a>, in case they are contained by different manifests. For example, locator values retrieved via the response header of the <code>HTTP</code> response have the highest priority. This provides a flexibility to publish copies of <a>PWP</a>-s on the <a>server</a> without the necessity to change, e.g., the <a>packed</a> versions.</p>

        <section class="appendix" id="complex_manifest_algorithm">
            <h2>Algorithm to retrieve the <a>PWP manifest</a> with possible combination of manifests</h2>

            <p>The goal of this algorithm is to obtain the <a>PWP manifest</a> based on the value of the <a>state independent locator</a> <strong>L</strong>. This algorithm is performed by the <a>PWP Processor</a>, typically when it is initialized with the state independent locator <strong>L</strong> of a particular <a>PWP</a> instance. The core of the algorithm consists of retrieving the <a>PWP manifest</a> based on the HTTP(S) responses on a <code>HTTP GET</code> request on <strong>L</strong>.</p>

            <p>In what follows, as an abuse of notation, <code>HTTP&nbsp;GET&nbsp;U</code>, for a URL <code>U</code>, refers to an <code>HTTP</code> or <code>HTTPS</code> request issued to the domain part of <code>U</code>, using the path from <code>U</code>. I.e., if <code>U</code> is <code>http://www.ex.org/a/b/c</code>, then <code>HTTP&nbsp;GET&nbsp;U</code> stands for:</p>

            <pre><code>GET /a/b/c HTTP/1.1
    Host: www.ex.org</code></pre>

            <p>See [[rfc2616]] for further details.</p>

            <p>As another abuse of notation, the algorithm refers to a <a>manifest</a> retrieved <code>HTTP</code> and then manipulated via, e.g., the <a>combination of manifests</a>; that step, in fact, involves <em>parsing</em> the serialized <a data-lt="manifest">manifest file</a> and manipulate the abstract content instead in an implementation specific way.</p>

            <p>With these prerequisites, the algorithm is as follows (see also <a href="#fig-flow-get-2">the figure</a> as a visual aid to the algorithm). The input to the algorithm is the <a>state independent locator</a> of the <a>PWP</a> instance, <strong>L</strong>.</p>

            <ol class="algorithm" id="complex_algorithm">
                <li>Create two, initially empty, <a data-lt="manifest">manifests</a>, denoted respectively <strong>M<sub>2</sub></strong> and <strong>M<sub>3</sub></strong>.</li>

                <li>Issue an <code>HTTP&nbsp;GET&nbsp;L</code> request.</li>

                <li>If the response is not successful (e.g., the response code is a 404), the process fails with no results.</li>

                <li>Otherwise, perform the two, independent processing steps below, yielding possibly new values to <strong>M<sub>2</sub></strong> and <strong>M<sub>3</sub></strong>, respectively.
                    <ol>
                        <li>Consider the resource returned by the <code>HTTP</code> request to, possibly, provide a new value to <strong>M<sub>2</sub></strong> as follows. Depending on the media type of the response, take the following actions:
                            <ol>
                                <li>If the response is a packaged PWP instance (identified via the media type to be specified for the packed <a>state</a> of a PWP):
                                    <ol>
                                        <li>Unpack the package, and retrieve the <a>manifest</a> embedded in the package as (to be) specified by the packed state of a PWP.</li>
                                        <li><strong>M<sub>2</sub></strong> is set to the retrieved manifest.</li>
                                    </ol>
                                </li>

                                <li>Otherwise, if the resource is a PWP <a>manifest</a>, as identified by its media type, set <strong>M<sub>2</sub></strong> to this resource.</li>

                                <li>Otherwise the resource is an HTML file. Take the following actions:
                                    <ol>
                                        <li>Create two, initially empty, <a data-lt="manifest">manifests</a>, respectively <strong>M<sub>1,0</sub></strong> and <strong>M<sub>1,1</sub></strong></li>

                                        <li>Perform the two, independent processing steps below, yielding possibly new values to <strong>M<sub>1,0</sub></strong> and <strong>M<sub>1,1</sub></strong>, respectively.
                                            <ol>
                                                <li>If the HTML content includes a <code>&lt;link&nbsp;rel="pwp_manifest"&nbsp;href="URI"&gt;</code> in the header:
                                                    <ol>
                                                        <li>Issue a <code>HTTP&nbsp;GET&nbsp;URI</code> request</li>
                                                        <li>If the response is successful, <strong>M<sub>1,0</sub></strong> is set to the content returned in the response</li>
                                                    </ol>
                                                </li>

                                                <li>If the HTML content includes a <a>manifest</a> content embedded in a <code>&lt;script&gt;</code> element, serialized in to one of the accepted serializations for PWP manifests
                                                    <ol>
                                                        <li>Retrieve and parse the content of the <code>&lt;script&gt;</code> element</li>
                                                        <li>If parsing is successful, <strong>M<sub>1,1</sub></strong> is set to the parsed manifest</li>
                                                    </ol>
                                                </li>
                                            </ol>
                                        </li>
                                        <li>Set <strong>M<sub>2</sub></strong>&nbsp;=&nbsp;<strong>M<sub>1,0</sub></strong>&nbsp;โ&nbsp;<strong>M<sub>1,1</sub></strong></li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                        <li>Consider the HTTP Response header to, possibly, provide a new value to <strong>M3</strong> as follows.
                            <ol>
                                <li>If the response header includes a header of the form <code>LINK&nbsp;&lt;URI&gt;;&nbsp;rel="pwp_manifest"</code> (see [[rfc5988]]) then
                                    <ol>
                                        <li>Issue an <code>HTTP&nbsp;GET&nbsp;URI</code> request</li>
                                        <li>If the response is successful, <strong>M<sub>3</sub></strong> is set to the content returned in the response.</li>
                                    </ol>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </li>
                <li>The final <a>PWP manifest</a> is set to <strong>M</strong>&nbsp;=&nbsp;<strong>M<sub>2</sub></strong>&nbsp;โ&nbsp;<strong>M<sub>3</sub></strong> and returned.</li>
            </ol>

            <p>An important point of the algorithm is that it defines a priority for the <a>manifest items</a> in case several <a>manifest</a> instances contains respective values (see the definition for the <a>combination of manifests</a>). At present, the priority is as follows, in decreasing priority order:</p>

            <ol>
                <li>Manifest referred to by the <code>HTTP</code> Link Header</li>
                <li>Manifest extracted from the payload; if that means retrieving the manifest from the HTML content, then:
                    <ol>
                        <li>Manifest embedded in the HTML</li>
                        <li>Manifest referred to by a <code>&lt;link&gt;</code> element.</li>
                    </ol>
                    <p>otherwise the access to the manifest via a package or directly through the payload are mutually exclusive, i.e., priority among them do not apply</p>
                </li>
            </ol>

            <p>
                See also the <a href="#man_alg_notes">notes on the simple manifest extraction algorithm</a>; those are relevant for this version of the algorithm, too.
            </p>

            <figure id="fig-flow-get-2" class="overlarge">
                <img src="figures/Complex_manifest_access.svg" width="70%" alt="Flowchart of what happens when a Portable Web Publication is retrieved by the user and how this leads to the PWP manifest; manifest are combined" longdesc="#complex_algorithm"/>
                <figcaption>Visual representation of the <a href="#algorithm">algorithm</a> to retrieve the <a>PWP manifest</a> with a possibility for combination. The figure is also available in <a href="figures/Complex_manifest_access.svg">SVG</a> and <a href="figures/Complex_manifest_access.png">PNG</a> formats.</figcaption>
            </figure>
        </section>
    </section>
  </body>
</html>
